import { EventEmitter, OnChanges, OnInit, SimpleChanges } from '@angular/core';
import { AccessibleComponent } from '../accessible.component';
import { AccessibilityConfig } from '../../model/accessibility.interface';
import { Action } from '../../model/action.enum';
import { Description } from '../../model/description.interface';
import { Image, ImageModalEvent } from '../../model/image.class';
import { InternalLibImage } from '../../model/image-internal.class';
import { KeyboardConfig } from '../../model/keyboard-config.interface';
import { LoadingConfig } from '../../model/loading-config.interface';
import { SlideConfig } from '../../model/slide-config.interface';
import { CurrentImageConfig } from '../../model/current-image-config.interface';
/**
 * Interface to describe the Load Event, used to
 * emit an event when the image is finally loaded and the spinner has gone.
 */
import * as ɵngcc0 from '@angular/core';
export interface ImageLoadEvent {
    status: boolean;
    index: number;
    id: number;
}
/**
 * Component with the current image with some additional elements like arrows and side previews.
 */
export declare class CurrentImageComponent extends AccessibleComponent implements OnInit, OnChanges {
    /**
     * Object of type `InternalLibImage` that represent the visible image.
     */
    currentImage: InternalLibImage;
    /**
     * Array of `InternalLibImage` that represent the model of this library with all images,
     * thumbs and so on.
     */
    images: InternalLibImage[];
    /**
     * Boolean that it is true if the modal gallery is visible.
     * If yes, also this component should be visible.
     */
    isOpen: boolean;
    /**
     * Interface to configure current image in modal-gallery.
     * For instance you can disable navigation on click on current image (enabled by default).
     */
    currentImageConfig: CurrentImageConfig;
    /**
     * Object of type `LoadingConfig` that contains fields like enable/disable
     * and a way to choose a loading spinner.
     * TODO: this will be removed in version 6.0.0 because it will be into currentImageConfig
     */
    loadingConfig: LoadingConfig;
    /**
     * Object of type `Description` to configure and show image descriptions.
     * TODO: this will be removed in version 6.0.0 because it will be into currentImageConfig
     */
    descriptionConfig: Description;
    /**
     * Object of type `SlideConfig` to get `infinite sliding`.
     */
    slideConfig: SlideConfig;
    /**
     * Object of type `AccessibilityConfig` to init custom accessibility features.
     * For instance, it contains titles, alt texts, aria-labels and so on.
     */
    accessibilityConfig: AccessibilityConfig;
    /**
     * Object of type `KeyboardConfig` to assign custom keys to both ESC, RIGHT and LEFT keyboard's actions.
     */
    keyboardConfig: KeyboardConfig;
    /**
     * Output to emit an event when images are loaded. The payload contains an `ImageLoadEvent`.
     */
    loadImage: EventEmitter<ImageLoadEvent>;
    /**
     * Output to emit any changes of the current image. The payload contains an `ImageModalEvent`.
     */
    changeImage: EventEmitter<ImageModalEvent>;
    /**
     * Output to emit an event when the modal gallery is closed. The payload contains an `ImageModalEvent`.
     */
    close: EventEmitter<ImageModalEvent>;
    /**
     * Enum of type `Action` that represents a mouse click on a button.
     * Declared here to be used inside the template.
     */
    clickAction: Action;
    /**
     * Enum of type `Action` that represents a keyboard action.
     * Declared here to be used inside the template.
     */
    keyboardAction: Action;
    /**
     * Boolean that it's true when you are watching the first image (currently visible).
     * False by default
     */
    isFirstImage: boolean;
    /**
     * Boolean that it's true when you are watching the last image (currently visible).
     * False by default
     */
    isLastImage: boolean;
    /**
     * Boolean that it's true if an image of the modal gallery is still loading.
     * True by default
     */
    loading: boolean;
    /**
     * Object of type `CurrentImageConfig` exposed to the template. This field is initialized
     * applying transformations, default values and so on to the input of the same type.
     */
    configCurrentImage: CurrentImageConfig;
    /**
     * Object of type `LoadingConfig` exposed to the template. This field is initialized
     * applying transformations, default values and so on to the input of the same type.
     * TODO: this will be removed in version 6.0.0 because it will be into configCurrentImage
     */
    configLoading: LoadingConfig;
    /**
     * `Description` object initialized applying transformations, default values
     * and so on to the input of the same type.
     * TODO: this will be removed in version 6.0.0 because it will be into configCurrentImage
     */
    description: Description;
    /**
     * Private object without type to define all swipe actions used by hammerjs.
     */
    private SWIPE_ACTION;
    /**
     * Method ´ngOnInit´ to build both `defaultLoading` and `defaultDescription` applying default values.
     * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
     * In particular, it's called only one time!!!
     */
    ngOnInit(): void;
    /**
     * Method ´ngOnChanges´ to update `loading` status and emit events.
     * If the gallery is open, then it will also manage boundary arrows and sliding.
     * This is an Angular's lifecycle hook, so its called automatically by Angular itself.
     * In particular, it's called when any data-bound property of a directive changes!!!
     */
    ngOnChanges(changes: SimpleChanges): void;
    /**
     * Method to handle keypress based on the `keyboardConfig` input. It gets the keyCode of
     * the key that triggered the keypress event to navigate between images or to close the modal gallery.
     * @param {number} keyCode of the key that triggered the keypress event
     */
    onKeyPress(keyCode: number): void;
    /**
     * Method to get the image description based on the image object itself.
     * If you provide a full description this will be the visible description, otherwise,
     * it will be built using the `Description` object, concatenating its fields with a specific logic.
     * @param {Image} image to get its description. If not provided it will be the current image
     * @returns String description of the image (or the current image if not provided)
     * @throws an Error if description isn't available
     */
    getDescriptionToDisplay(image?: Image): string;
    /**
     * Method to get the title attributes based on descriptions.
     * This is useful to prevent accessibility issues, because if DescriptionStrategy is ALWAYS_HIDDEN,
     * it prevents an empty string as title.
     * @param {Image} image to get its description. If not provided it will be the current image
     * @returns String title of the image based on descriptions
     * @throws an Error if description isn't available
     */
    getTitleToDisplay(image?: Image): string;
    /**
     * Method to get `alt attribute`.
     * `alt` specifies an alternate text for an image, if the image cannot be displayed.
     * @param {Image} image to get its alt description. If not provided it will be the current image
     * @returns String alt description of the image (or the current image if not provided)
     */
    getAltDescriptionByImage(image?: Image): string;
    /**
     * Method to get the left side preview image.
     * @returns {Image} the image to show as size preview on the left
     */
    getLeftPreviewImage(): Image;
    /**
     * Method to get the right side preview image.
     * @returns {Image} the image to show as size preview on the right
     */
    getRightPreviewImage(): Image;
    /**
     * Method called by events from both keyboard and mouse on an image.
     * This will invoke the nextImage method (except for click events, because It checks also if navigateOnClick === true).
     * @param {KeyboardEvent | MouseEvent} event payload
     * @param {Action} action that triggered the event or `Action.NORMAL` if not provided
     */
    onImageEvent(event: KeyboardEvent | MouseEvent, action?: Action): void;
    /**
     * Method called by events from both keyboard and mouse on a navigation arrow.
     * @param {string} direction of the navigation that can be either 'next' or 'prev'
     * @param {KeyboardEvent | MouseEvent} event payload
     * @param {Action} action that triggered the event or `Action.NORMAL` if not provided
     */
    onNavigationEvent(direction: string, event: KeyboardEvent, action?: Action): void;
    /**
     * Method to go back to the previous image.
     * @param action Enum of type `Action` that represents the source
     *  action that moved back to the previous image. `Action.NORMAL` by default.
     */
    prevImage(action?: Action): void;
    /**
     * Method to go back to the previous image.
     * @param action Enum of type `Action` that represents the source
     *  action that moved to the next image. `Action.NORMAL` by default.
     */
    nextImage(action?: Action): void;
    /**
     * Method to emit an event as loadImage output to say that the requested image if loaded.
     * This method is invoked by the javascript's 'load' event on an img tag.
     * @param {Event} event that triggered the load
     */
    onImageLoad(event: Event): void;
    /**
     * Method used by Hammerjs to support touch gestures.
     * @param action String that represent the direction of the swipe action. 'swiperight' by default.
     */
    swipe(action?: string): void;
    /**
     * Method used in `modal-gallery.component` to get the index of an image to delete.
     * @param {Image} image to get the index, or the visible image, if not passed
     * @returns {number} the index of the image
     */
    getIndexToDelete(image?: Image): number;
    /**
     * Private method to update both `isFirstImage` and `isLastImage` based on
     * the index of the current image.
     * @param {number} currentIndex is the index of the current image
     */
    private handleBoundaries(currentIndex);
    /**
     * Private method to manage boundary arrows and sliding.
     * This is based on the slideConfig input to enable/disable 'infinite sliding'.
     * @param {number} index of the visible image
     */
    private manageSlideConfig(index);
    /**
     * Private method to check if next/prev actions should be blocked.
     * It checks if slideConfig.infinite === false and if the image index is equals to the input parameter.
     * If yes, it returns true to say that sliding should be blocked, otherwise not.
     * @param {number} boundaryIndex that could be either the beginning index (0) or the last index
     *  of images (this.images.length - 1).
     * @returns {boolean} true if slideConfig.infinite === false and the current index is
     *  either the first or the last one.
     */
    private isPreventSliding(boundaryIndex);
    /**
     * Private method to get the next index.
     * This is necessary because at the end, when you call next again, you'll go to the first image.
     * That happens because all modal images are shown like in a circle.
     */
    private getNextImage();
    /**
     * Private method to get the previous index.
     * This is necessary because at index 0, when you call prev again, you'll go to the last image.
     * That happens because all modal images are shown like in a circle.
     */
    private getPrevImage();
    /**
     * Private method to build a text description.
     * This is used also to create titles.
     * @param {Image} image to get its description. If not provided it will be the current image.
     * @param {boolean} imageWithoutDescription is a boolean that it's true if the image hasn't a 'modal' description.
     * @returns String description built concatenating image fields with a specific logic.
     */
    private buildTextDescription(image, imageWithoutDescription);
    static ɵfac: ɵngcc0.ɵɵFactoryDef<CurrentImageComponent, never>;
    static ɵcmp: ɵngcc0.ɵɵComponentDefWithMeta<CurrentImageComponent, "ks-current-image", never, { "currentImage": "currentImage"; "images": "images"; "isOpen": "isOpen"; "currentImageConfig": "currentImageConfig"; "loadingConfig": "loadingConfig"; "descriptionConfig": "descriptionConfig"; "slideConfig": "slideConfig"; "accessibilityConfig": "accessibilityConfig"; "keyboardConfig": "keyboardConfig"; }, { "loadImage": "loadImage"; "changeImage": "changeImage"; "close": "close"; }, never, never>;
}

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY3VycmVudC1pbWFnZS5jb21wb25lbnQuZC50cyIsInNvdXJjZXMiOlsiY3VycmVudC1pbWFnZS5jb21wb25lbnQuZC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciwgT25DaGFuZ2VzLCBPbkluaXQsIFNpbXBsZUNoYW5nZXMgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFjY2Vzc2libGVDb21wb25lbnQgfSBmcm9tICcuLi9hY2Nlc3NpYmxlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBBY2Nlc3NpYmlsaXR5Q29uZmlnIH0gZnJvbSAnLi4vLi4vbW9kZWwvYWNjZXNzaWJpbGl0eS5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQWN0aW9uIH0gZnJvbSAnLi4vLi4vbW9kZWwvYWN0aW9uLmVudW0nO1xuaW1wb3J0IHsgRGVzY3JpcHRpb24gfSBmcm9tICcuLi8uLi9tb2RlbC9kZXNjcmlwdGlvbi5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgSW1hZ2UsIEltYWdlTW9kYWxFdmVudCB9IGZyb20gJy4uLy4uL21vZGVsL2ltYWdlLmNsYXNzJztcbmltcG9ydCB7IEludGVybmFsTGliSW1hZ2UgfSBmcm9tICcuLi8uLi9tb2RlbC9pbWFnZS1pbnRlcm5hbC5jbGFzcyc7XG5pbXBvcnQgeyBLZXlib2FyZENvbmZpZyB9IGZyb20gJy4uLy4uL21vZGVsL2tleWJvYXJkLWNvbmZpZy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgTG9hZGluZ0NvbmZpZyB9IGZyb20gJy4uLy4uL21vZGVsL2xvYWRpbmctY29uZmlnLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTbGlkZUNvbmZpZyB9IGZyb20gJy4uLy4uL21vZGVsL3NsaWRlLWNvbmZpZy5pbnRlcmZhY2UnO1xuaW1wb3J0IHsgQ3VycmVudEltYWdlQ29uZmlnIH0gZnJvbSAnLi4vLi4vbW9kZWwvY3VycmVudC1pbWFnZS1jb25maWcuaW50ZXJmYWNlJztcbi8qKlxuICogSW50ZXJmYWNlIHRvIGRlc2NyaWJlIHRoZSBMb2FkIEV2ZW50LCB1c2VkIHRvXG4gKiBlbWl0IGFuIGV2ZW50IHdoZW4gdGhlIGltYWdlIGlzIGZpbmFsbHkgbG9hZGVkIGFuZCB0aGUgc3Bpbm5lciBoYXMgZ29uZS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbWFnZUxvYWRFdmVudCB7XG4gICAgc3RhdHVzOiBib29sZWFuO1xuICAgIGluZGV4OiBudW1iZXI7XG4gICAgaWQ6IG51bWJlcjtcbn1cbi8qKlxuICogQ29tcG9uZW50IHdpdGggdGhlIGN1cnJlbnQgaW1hZ2Ugd2l0aCBzb21lIGFkZGl0aW9uYWwgZWxlbWVudHMgbGlrZSBhcnJvd3MgYW5kIHNpZGUgcHJldmlld3MuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGNsYXNzIEN1cnJlbnRJbWFnZUNvbXBvbmVudCBleHRlbmRzIEFjY2Vzc2libGVDb21wb25lbnQgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcyB7XG4gICAgLyoqXG4gICAgICogT2JqZWN0IG9mIHR5cGUgYEludGVybmFsTGliSW1hZ2VgIHRoYXQgcmVwcmVzZW50IHRoZSB2aXNpYmxlIGltYWdlLlxuICAgICAqL1xuICAgIGN1cnJlbnRJbWFnZTogSW50ZXJuYWxMaWJJbWFnZTtcbiAgICAvKipcbiAgICAgKiBBcnJheSBvZiBgSW50ZXJuYWxMaWJJbWFnZWAgdGhhdCByZXByZXNlbnQgdGhlIG1vZGVsIG9mIHRoaXMgbGlicmFyeSB3aXRoIGFsbCBpbWFnZXMsXG4gICAgICogdGh1bWJzIGFuZCBzbyBvbi5cbiAgICAgKi9cbiAgICBpbWFnZXM6IEludGVybmFsTGliSW1hZ2VbXTtcbiAgICAvKipcbiAgICAgKiBCb29sZWFuIHRoYXQgaXQgaXMgdHJ1ZSBpZiB0aGUgbW9kYWwgZ2FsbGVyeSBpcyB2aXNpYmxlLlxuICAgICAqIElmIHllcywgYWxzbyB0aGlzIGNvbXBvbmVudCBzaG91bGQgYmUgdmlzaWJsZS5cbiAgICAgKi9cbiAgICBpc09wZW46IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogSW50ZXJmYWNlIHRvIGNvbmZpZ3VyZSBjdXJyZW50IGltYWdlIGluIG1vZGFsLWdhbGxlcnkuXG4gICAgICogRm9yIGluc3RhbmNlIHlvdSBjYW4gZGlzYWJsZSBuYXZpZ2F0aW9uIG9uIGNsaWNrIG9uIGN1cnJlbnQgaW1hZ2UgKGVuYWJsZWQgYnkgZGVmYXVsdCkuXG4gICAgICovXG4gICAgY3VycmVudEltYWdlQ29uZmlnOiBDdXJyZW50SW1hZ2VDb25maWc7XG4gICAgLyoqXG4gICAgICogT2JqZWN0IG9mIHR5cGUgYExvYWRpbmdDb25maWdgIHRoYXQgY29udGFpbnMgZmllbGRzIGxpa2UgZW5hYmxlL2Rpc2FibGVcbiAgICAgKiBhbmQgYSB3YXkgdG8gY2hvb3NlIGEgbG9hZGluZyBzcGlubmVyLlxuICAgICAqIFRPRE86IHRoaXMgd2lsbCBiZSByZW1vdmVkIGluIHZlcnNpb24gNi4wLjAgYmVjYXVzZSBpdCB3aWxsIGJlIGludG8gY3VycmVudEltYWdlQ29uZmlnXG4gICAgICovXG4gICAgbG9hZGluZ0NvbmZpZzogTG9hZGluZ0NvbmZpZztcbiAgICAvKipcbiAgICAgKiBPYmplY3Qgb2YgdHlwZSBgRGVzY3JpcHRpb25gIHRvIGNvbmZpZ3VyZSBhbmQgc2hvdyBpbWFnZSBkZXNjcmlwdGlvbnMuXG4gICAgICogVE9ETzogdGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gdmVyc2lvbiA2LjAuMCBiZWNhdXNlIGl0IHdpbGwgYmUgaW50byBjdXJyZW50SW1hZ2VDb25maWdcbiAgICAgKi9cbiAgICBkZXNjcmlwdGlvbkNvbmZpZzogRGVzY3JpcHRpb247XG4gICAgLyoqXG4gICAgICogT2JqZWN0IG9mIHR5cGUgYFNsaWRlQ29uZmlnYCB0byBnZXQgYGluZmluaXRlIHNsaWRpbmdgLlxuICAgICAqL1xuICAgIHNsaWRlQ29uZmlnOiBTbGlkZUNvbmZpZztcbiAgICAvKipcbiAgICAgKiBPYmplY3Qgb2YgdHlwZSBgQWNjZXNzaWJpbGl0eUNvbmZpZ2AgdG8gaW5pdCBjdXN0b20gYWNjZXNzaWJpbGl0eSBmZWF0dXJlcy5cbiAgICAgKiBGb3IgaW5zdGFuY2UsIGl0IGNvbnRhaW5zIHRpdGxlcywgYWx0IHRleHRzLCBhcmlhLWxhYmVscyBhbmQgc28gb24uXG4gICAgICovXG4gICAgYWNjZXNzaWJpbGl0eUNvbmZpZzogQWNjZXNzaWJpbGl0eUNvbmZpZztcbiAgICAvKipcbiAgICAgKiBPYmplY3Qgb2YgdHlwZSBgS2V5Ym9hcmRDb25maWdgIHRvIGFzc2lnbiBjdXN0b20ga2V5cyB0byBib3RoIEVTQywgUklHSFQgYW5kIExFRlQga2V5Ym9hcmQncyBhY3Rpb25zLlxuICAgICAqL1xuICAgIGtleWJvYXJkQ29uZmlnOiBLZXlib2FyZENvbmZpZztcbiAgICAvKipcbiAgICAgKiBPdXRwdXQgdG8gZW1pdCBhbiBldmVudCB3aGVuIGltYWdlcyBhcmUgbG9hZGVkLiBUaGUgcGF5bG9hZCBjb250YWlucyBhbiBgSW1hZ2VMb2FkRXZlbnRgLlxuICAgICAqL1xuICAgIGxvYWRJbWFnZTogRXZlbnRFbWl0dGVyPEltYWdlTG9hZEV2ZW50PjtcbiAgICAvKipcbiAgICAgKiBPdXRwdXQgdG8gZW1pdCBhbnkgY2hhbmdlcyBvZiB0aGUgY3VycmVudCBpbWFnZS4gVGhlIHBheWxvYWQgY29udGFpbnMgYW4gYEltYWdlTW9kYWxFdmVudGAuXG4gICAgICovXG4gICAgY2hhbmdlSW1hZ2U6IEV2ZW50RW1pdHRlcjxJbWFnZU1vZGFsRXZlbnQ+O1xuICAgIC8qKlxuICAgICAqIE91dHB1dCB0byBlbWl0IGFuIGV2ZW50IHdoZW4gdGhlIG1vZGFsIGdhbGxlcnkgaXMgY2xvc2VkLiBUaGUgcGF5bG9hZCBjb250YWlucyBhbiBgSW1hZ2VNb2RhbEV2ZW50YC5cbiAgICAgKi9cbiAgICBjbG9zZTogRXZlbnRFbWl0dGVyPEltYWdlTW9kYWxFdmVudD47XG4gICAgLyoqXG4gICAgICogRW51bSBvZiB0eXBlIGBBY3Rpb25gIHRoYXQgcmVwcmVzZW50cyBhIG1vdXNlIGNsaWNrIG9uIGEgYnV0dG9uLlxuICAgICAqIERlY2xhcmVkIGhlcmUgdG8gYmUgdXNlZCBpbnNpZGUgdGhlIHRlbXBsYXRlLlxuICAgICAqL1xuICAgIGNsaWNrQWN0aW9uOiBBY3Rpb247XG4gICAgLyoqXG4gICAgICogRW51bSBvZiB0eXBlIGBBY3Rpb25gIHRoYXQgcmVwcmVzZW50cyBhIGtleWJvYXJkIGFjdGlvbi5cbiAgICAgKiBEZWNsYXJlZCBoZXJlIHRvIGJlIHVzZWQgaW5zaWRlIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKi9cbiAgICBrZXlib2FyZEFjdGlvbjogQWN0aW9uO1xuICAgIC8qKlxuICAgICAqIEJvb2xlYW4gdGhhdCBpdCdzIHRydWUgd2hlbiB5b3UgYXJlIHdhdGNoaW5nIHRoZSBmaXJzdCBpbWFnZSAoY3VycmVudGx5IHZpc2libGUpLlxuICAgICAqIEZhbHNlIGJ5IGRlZmF1bHRcbiAgICAgKi9cbiAgICBpc0ZpcnN0SW1hZ2U6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQm9vbGVhbiB0aGF0IGl0J3MgdHJ1ZSB3aGVuIHlvdSBhcmUgd2F0Y2hpbmcgdGhlIGxhc3QgaW1hZ2UgKGN1cnJlbnRseSB2aXNpYmxlKS5cbiAgICAgKiBGYWxzZSBieSBkZWZhdWx0XG4gICAgICovXG4gICAgaXNMYXN0SW1hZ2U6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogQm9vbGVhbiB0aGF0IGl0J3MgdHJ1ZSBpZiBhbiBpbWFnZSBvZiB0aGUgbW9kYWwgZ2FsbGVyeSBpcyBzdGlsbCBsb2FkaW5nLlxuICAgICAqIFRydWUgYnkgZGVmYXVsdFxuICAgICAqL1xuICAgIGxvYWRpbmc6IGJvb2xlYW47XG4gICAgLyoqXG4gICAgICogT2JqZWN0IG9mIHR5cGUgYEN1cnJlbnRJbWFnZUNvbmZpZ2AgZXhwb3NlZCB0byB0aGUgdGVtcGxhdGUuIFRoaXMgZmllbGQgaXMgaW5pdGlhbGl6ZWRcbiAgICAgKiBhcHBseWluZyB0cmFuc2Zvcm1hdGlvbnMsIGRlZmF1bHQgdmFsdWVzIGFuZCBzbyBvbiB0byB0aGUgaW5wdXQgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAgKi9cbiAgICBjb25maWdDdXJyZW50SW1hZ2U6IEN1cnJlbnRJbWFnZUNvbmZpZztcbiAgICAvKipcbiAgICAgKiBPYmplY3Qgb2YgdHlwZSBgTG9hZGluZ0NvbmZpZ2AgZXhwb3NlZCB0byB0aGUgdGVtcGxhdGUuIFRoaXMgZmllbGQgaXMgaW5pdGlhbGl6ZWRcbiAgICAgKiBhcHBseWluZyB0cmFuc2Zvcm1hdGlvbnMsIGRlZmF1bHQgdmFsdWVzIGFuZCBzbyBvbiB0byB0aGUgaW5wdXQgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAgKiBUT0RPOiB0aGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDYuMC4wIGJlY2F1c2UgaXQgd2lsbCBiZSBpbnRvIGNvbmZpZ0N1cnJlbnRJbWFnZVxuICAgICAqL1xuICAgIGNvbmZpZ0xvYWRpbmc6IExvYWRpbmdDb25maWc7XG4gICAgLyoqXG4gICAgICogYERlc2NyaXB0aW9uYCBvYmplY3QgaW5pdGlhbGl6ZWQgYXBwbHlpbmcgdHJhbnNmb3JtYXRpb25zLCBkZWZhdWx0IHZhbHVlc1xuICAgICAqIGFuZCBzbyBvbiB0byB0aGUgaW5wdXQgb2YgdGhlIHNhbWUgdHlwZS5cbiAgICAgKiBUT0RPOiB0aGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiB2ZXJzaW9uIDYuMC4wIGJlY2F1c2UgaXQgd2lsbCBiZSBpbnRvIGNvbmZpZ0N1cnJlbnRJbWFnZVxuICAgICAqL1xuICAgIGRlc2NyaXB0aW9uOiBEZXNjcmlwdGlvbjtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG9iamVjdCB3aXRob3V0IHR5cGUgdG8gZGVmaW5lIGFsbCBzd2lwZSBhY3Rpb25zIHVzZWQgYnkgaGFtbWVyanMuXG4gICAgICovXG4gICAgcHJpdmF0ZSBTV0lQRV9BQ1RJT047XG4gICAgLyoqXG4gICAgICogTWV0aG9kIMK0bmdPbkluaXTCtCB0byBidWlsZCBib3RoIGBkZWZhdWx0TG9hZGluZ2AgYW5kIGBkZWZhdWx0RGVzY3JpcHRpb25gIGFwcGx5aW5nIGRlZmF1bHQgdmFsdWVzLlxuICAgICAqIFRoaXMgaXMgYW4gQW5ndWxhcidzIGxpZmVjeWNsZSBob29rLCBzbyBpdHMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgQW5ndWxhciBpdHNlbGYuXG4gICAgICogSW4gcGFydGljdWxhciwgaXQncyBjYWxsZWQgb25seSBvbmUgdGltZSEhIVxuICAgICAqL1xuICAgIG5nT25Jbml0KCk6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIMK0bmdPbkNoYW5nZXPCtCB0byB1cGRhdGUgYGxvYWRpbmdgIHN0YXR1cyBhbmQgZW1pdCBldmVudHMuXG4gICAgICogSWYgdGhlIGdhbGxlcnkgaXMgb3BlbiwgdGhlbiBpdCB3aWxsIGFsc28gbWFuYWdlIGJvdW5kYXJ5IGFycm93cyBhbmQgc2xpZGluZy5cbiAgICAgKiBUaGlzIGlzIGFuIEFuZ3VsYXIncyBsaWZlY3ljbGUgaG9vaywgc28gaXRzIGNhbGxlZCBhdXRvbWF0aWNhbGx5IGJ5IEFuZ3VsYXIgaXRzZWxmLlxuICAgICAqIEluIHBhcnRpY3VsYXIsIGl0J3MgY2FsbGVkIHdoZW4gYW55IGRhdGEtYm91bmQgcHJvcGVydHkgb2YgYSBkaXJlY3RpdmUgY2hhbmdlcyEhIVxuICAgICAqL1xuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBoYW5kbGUga2V5cHJlc3MgYmFzZWQgb24gdGhlIGBrZXlib2FyZENvbmZpZ2AgaW5wdXQuIEl0IGdldHMgdGhlIGtleUNvZGUgb2ZcbiAgICAgKiB0aGUga2V5IHRoYXQgdHJpZ2dlcmVkIHRoZSBrZXlwcmVzcyBldmVudCB0byBuYXZpZ2F0ZSBiZXR3ZWVuIGltYWdlcyBvciB0byBjbG9zZSB0aGUgbW9kYWwgZ2FsbGVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0ga2V5Q29kZSBvZiB0aGUga2V5IHRoYXQgdHJpZ2dlcmVkIHRoZSBrZXlwcmVzcyBldmVudFxuICAgICAqL1xuICAgIG9uS2V5UHJlc3Moa2V5Q29kZTogbnVtYmVyKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZ2V0IHRoZSBpbWFnZSBkZXNjcmlwdGlvbiBiYXNlZCBvbiB0aGUgaW1hZ2Ugb2JqZWN0IGl0c2VsZi5cbiAgICAgKiBJZiB5b3UgcHJvdmlkZSBhIGZ1bGwgZGVzY3JpcHRpb24gdGhpcyB3aWxsIGJlIHRoZSB2aXNpYmxlIGRlc2NyaXB0aW9uLCBvdGhlcndpc2UsXG4gICAgICogaXQgd2lsbCBiZSBidWlsdCB1c2luZyB0aGUgYERlc2NyaXB0aW9uYCBvYmplY3QsIGNvbmNhdGVuYXRpbmcgaXRzIGZpZWxkcyB3aXRoIGEgc3BlY2lmaWMgbG9naWMuXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2UgdG8gZ2V0IGl0cyBkZXNjcmlwdGlvbi4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgdGhlIGN1cnJlbnQgaW1hZ2VcbiAgICAgKiBAcmV0dXJucyBTdHJpbmcgZGVzY3JpcHRpb24gb2YgdGhlIGltYWdlIChvciB0aGUgY3VycmVudCBpbWFnZSBpZiBub3QgcHJvdmlkZWQpXG4gICAgICogQHRocm93cyBhbiBFcnJvciBpZiBkZXNjcmlwdGlvbiBpc24ndCBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBnZXREZXNjcmlwdGlvblRvRGlzcGxheShpbWFnZT86IEltYWdlKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBnZXQgdGhlIHRpdGxlIGF0dHJpYnV0ZXMgYmFzZWQgb24gZGVzY3JpcHRpb25zLlxuICAgICAqIFRoaXMgaXMgdXNlZnVsIHRvIHByZXZlbnQgYWNjZXNzaWJpbGl0eSBpc3N1ZXMsIGJlY2F1c2UgaWYgRGVzY3JpcHRpb25TdHJhdGVneSBpcyBBTFdBWVNfSElEREVOLFxuICAgICAqIGl0IHByZXZlbnRzIGFuIGVtcHR5IHN0cmluZyBhcyB0aXRsZS5cbiAgICAgKiBAcGFyYW0ge0ltYWdlfSBpbWFnZSB0byBnZXQgaXRzIGRlc2NyaXB0aW9uLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSB0aGUgY3VycmVudCBpbWFnZVxuICAgICAqIEByZXR1cm5zIFN0cmluZyB0aXRsZSBvZiB0aGUgaW1hZ2UgYmFzZWQgb24gZGVzY3JpcHRpb25zXG4gICAgICogQHRocm93cyBhbiBFcnJvciBpZiBkZXNjcmlwdGlvbiBpc24ndCBhdmFpbGFibGVcbiAgICAgKi9cbiAgICBnZXRUaXRsZVRvRGlzcGxheShpbWFnZT86IEltYWdlKTogc3RyaW5nO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBnZXQgYGFsdCBhdHRyaWJ1dGVgLlxuICAgICAqIGBhbHRgIHNwZWNpZmllcyBhbiBhbHRlcm5hdGUgdGV4dCBmb3IgYW4gaW1hZ2UsIGlmIHRoZSBpbWFnZSBjYW5ub3QgYmUgZGlzcGxheWVkLlxuICAgICAqIEBwYXJhbSB7SW1hZ2V9IGltYWdlIHRvIGdldCBpdHMgYWx0IGRlc2NyaXB0aW9uLiBJZiBub3QgcHJvdmlkZWQgaXQgd2lsbCBiZSB0aGUgY3VycmVudCBpbWFnZVxuICAgICAqIEByZXR1cm5zIFN0cmluZyBhbHQgZGVzY3JpcHRpb24gb2YgdGhlIGltYWdlIChvciB0aGUgY3VycmVudCBpbWFnZSBpZiBub3QgcHJvdmlkZWQpXG4gICAgICovXG4gICAgZ2V0QWx0RGVzY3JpcHRpb25CeUltYWdlKGltYWdlPzogSW1hZ2UpOiBzdHJpbmc7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGdldCB0aGUgbGVmdCBzaWRlIHByZXZpZXcgaW1hZ2UuXG4gICAgICogQHJldHVybnMge0ltYWdlfSB0aGUgaW1hZ2UgdG8gc2hvdyBhcyBzaXplIHByZXZpZXcgb24gdGhlIGxlZnRcbiAgICAgKi9cbiAgICBnZXRMZWZ0UHJldmlld0ltYWdlKCk6IEltYWdlO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBnZXQgdGhlIHJpZ2h0IHNpZGUgcHJldmlldyBpbWFnZS5cbiAgICAgKiBAcmV0dXJucyB7SW1hZ2V9IHRoZSBpbWFnZSB0byBzaG93IGFzIHNpemUgcHJldmlldyBvbiB0aGUgcmlnaHRcbiAgICAgKi9cbiAgICBnZXRSaWdodFByZXZpZXdJbWFnZSgpOiBJbWFnZTtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgY2FsbGVkIGJ5IGV2ZW50cyBmcm9tIGJvdGgga2V5Ym9hcmQgYW5kIG1vdXNlIG9uIGFuIGltYWdlLlxuICAgICAqIFRoaXMgd2lsbCBpbnZva2UgdGhlIG5leHRJbWFnZSBtZXRob2QgKGV4Y2VwdCBmb3IgY2xpY2sgZXZlbnRzLCBiZWNhdXNlIEl0IGNoZWNrcyBhbHNvIGlmIG5hdmlnYXRlT25DbGljayA9PT0gdHJ1ZSkuXG4gICAgICogQHBhcmFtIHtLZXlib2FyZEV2ZW50IHwgTW91c2VFdmVudH0gZXZlbnQgcGF5bG9hZFxuICAgICAqIEBwYXJhbSB7QWN0aW9ufSBhY3Rpb24gdGhhdCB0cmlnZ2VyZWQgdGhlIGV2ZW50IG9yIGBBY3Rpb24uTk9STUFMYCBpZiBub3QgcHJvdmlkZWRcbiAgICAgKi9cbiAgICBvbkltYWdlRXZlbnQoZXZlbnQ6IEtleWJvYXJkRXZlbnQgfCBNb3VzZUV2ZW50LCBhY3Rpb24/OiBBY3Rpb24pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCBjYWxsZWQgYnkgZXZlbnRzIGZyb20gYm90aCBrZXlib2FyZCBhbmQgbW91c2Ugb24gYSBuYXZpZ2F0aW9uIGFycm93LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBkaXJlY3Rpb24gb2YgdGhlIG5hdmlnYXRpb24gdGhhdCBjYW4gYmUgZWl0aGVyICduZXh0JyBvciAncHJldidcbiAgICAgKiBAcGFyYW0ge0tleWJvYXJkRXZlbnQgfCBNb3VzZUV2ZW50fSBldmVudCBwYXlsb2FkXG4gICAgICogQHBhcmFtIHtBY3Rpb259IGFjdGlvbiB0aGF0IHRyaWdnZXJlZCB0aGUgZXZlbnQgb3IgYEFjdGlvbi5OT1JNQUxgIGlmIG5vdCBwcm92aWRlZFxuICAgICAqL1xuICAgIG9uTmF2aWdhdGlvbkV2ZW50KGRpcmVjdGlvbjogc3RyaW5nLCBldmVudDogS2V5Ym9hcmRFdmVudCwgYWN0aW9uPzogQWN0aW9uKTogdm9pZDtcbiAgICAvKipcbiAgICAgKiBNZXRob2QgdG8gZ28gYmFjayB0byB0aGUgcHJldmlvdXMgaW1hZ2UuXG4gICAgICogQHBhcmFtIGFjdGlvbiBFbnVtIG9mIHR5cGUgYEFjdGlvbmAgdGhhdCByZXByZXNlbnRzIHRoZSBzb3VyY2VcbiAgICAgKiAgYWN0aW9uIHRoYXQgbW92ZWQgYmFjayB0byB0aGUgcHJldmlvdXMgaW1hZ2UuIGBBY3Rpb24uTk9STUFMYCBieSBkZWZhdWx0LlxuICAgICAqL1xuICAgIHByZXZJbWFnZShhY3Rpb24/OiBBY3Rpb24pOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB0byBnbyBiYWNrIHRvIHRoZSBwcmV2aW91cyBpbWFnZS5cbiAgICAgKiBAcGFyYW0gYWN0aW9uIEVudW0gb2YgdHlwZSBgQWN0aW9uYCB0aGF0IHJlcHJlc2VudHMgdGhlIHNvdXJjZVxuICAgICAqICBhY3Rpb24gdGhhdCBtb3ZlZCB0byB0aGUgbmV4dCBpbWFnZS4gYEFjdGlvbi5OT1JNQUxgIGJ5IGRlZmF1bHQuXG4gICAgICovXG4gICAgbmV4dEltYWdlKGFjdGlvbj86IEFjdGlvbik6IHZvaWQ7XG4gICAgLyoqXG4gICAgICogTWV0aG9kIHRvIGVtaXQgYW4gZXZlbnQgYXMgbG9hZEltYWdlIG91dHB1dCB0byBzYXkgdGhhdCB0aGUgcmVxdWVzdGVkIGltYWdlIGlmIGxvYWRlZC5cbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBpbnZva2VkIGJ5IHRoZSBqYXZhc2NyaXB0J3MgJ2xvYWQnIGV2ZW50IG9uIGFuIGltZyB0YWcuXG4gICAgICogQHBhcmFtIHtFdmVudH0gZXZlbnQgdGhhdCB0cmlnZ2VyZWQgdGhlIGxvYWRcbiAgICAgKi9cbiAgICBvbkltYWdlTG9hZChldmVudDogRXZlbnQpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIGJ5IEhhbW1lcmpzIHRvIHN1cHBvcnQgdG91Y2ggZ2VzdHVyZXMuXG4gICAgICogQHBhcmFtIGFjdGlvbiBTdHJpbmcgdGhhdCByZXByZXNlbnQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgc3dpcGUgYWN0aW9uLiAnc3dpcGVyaWdodCcgYnkgZGVmYXVsdC5cbiAgICAgKi9cbiAgICBzd2lwZShhY3Rpb24/OiBzdHJpbmcpOiB2b2lkO1xuICAgIC8qKlxuICAgICAqIE1ldGhvZCB1c2VkIGluIGBtb2RhbC1nYWxsZXJ5LmNvbXBvbmVudGAgdG8gZ2V0IHRoZSBpbmRleCBvZiBhbiBpbWFnZSB0byBkZWxldGUuXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2UgdG8gZ2V0IHRoZSBpbmRleCwgb3IgdGhlIHZpc2libGUgaW1hZ2UsIGlmIG5vdCBwYXNzZWRcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSB0aGUgaW5kZXggb2YgdGhlIGltYWdlXG4gICAgICovXG4gICAgZ2V0SW5kZXhUb0RlbGV0ZShpbWFnZT86IEltYWdlKTogbnVtYmVyO1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIHRvIHVwZGF0ZSBib3RoIGBpc0ZpcnN0SW1hZ2VgIGFuZCBgaXNMYXN0SW1hZ2VgIGJhc2VkIG9uXG4gICAgICogdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGltYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50SW5kZXggaXMgdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGltYWdlXG4gICAgICovXG4gICAgcHJpdmF0ZSBoYW5kbGVCb3VuZGFyaWVzKGN1cnJlbnRJbmRleCk7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgdG8gbWFuYWdlIGJvdW5kYXJ5IGFycm93cyBhbmQgc2xpZGluZy5cbiAgICAgKiBUaGlzIGlzIGJhc2VkIG9uIHRoZSBzbGlkZUNvbmZpZyBpbnB1dCB0byBlbmFibGUvZGlzYWJsZSAnaW5maW5pdGUgc2xpZGluZycuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IG9mIHRoZSB2aXNpYmxlIGltYWdlXG4gICAgICovXG4gICAgcHJpdmF0ZSBtYW5hZ2VTbGlkZUNvbmZpZyhpbmRleCk7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgdG8gY2hlY2sgaWYgbmV4dC9wcmV2IGFjdGlvbnMgc2hvdWxkIGJlIGJsb2NrZWQuXG4gICAgICogSXQgY2hlY2tzIGlmIHNsaWRlQ29uZmlnLmluZmluaXRlID09PSBmYWxzZSBhbmQgaWYgdGhlIGltYWdlIGluZGV4IGlzIGVxdWFscyB0byB0aGUgaW5wdXQgcGFyYW1ldGVyLlxuICAgICAqIElmIHllcywgaXQgcmV0dXJucyB0cnVlIHRvIHNheSB0aGF0IHNsaWRpbmcgc2hvdWxkIGJlIGJsb2NrZWQsIG90aGVyd2lzZSBub3QuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJvdW5kYXJ5SW5kZXggdGhhdCBjb3VsZCBiZSBlaXRoZXIgdGhlIGJlZ2lubmluZyBpbmRleCAoMCkgb3IgdGhlIGxhc3QgaW5kZXhcbiAgICAgKiAgb2YgaW1hZ2VzICh0aGlzLmltYWdlcy5sZW5ndGggLSAxKS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBzbGlkZUNvbmZpZy5pbmZpbml0ZSA9PT0gZmFsc2UgYW5kIHRoZSBjdXJyZW50IGluZGV4IGlzXG4gICAgICogIGVpdGhlciB0aGUgZmlyc3Qgb3IgdGhlIGxhc3Qgb25lLlxuICAgICAqL1xuICAgIHByaXZhdGUgaXNQcmV2ZW50U2xpZGluZyhib3VuZGFyeUluZGV4KTtcbiAgICAvKipcbiAgICAgKiBQcml2YXRlIG1ldGhvZCB0byBnZXQgdGhlIG5leHQgaW5kZXguXG4gICAgICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhdCB0aGUgZW5kLCB3aGVuIHlvdSBjYWxsIG5leHQgYWdhaW4sIHlvdSdsbCBnbyB0byB0aGUgZmlyc3QgaW1hZ2UuXG4gICAgICogVGhhdCBoYXBwZW5zIGJlY2F1c2UgYWxsIG1vZGFsIGltYWdlcyBhcmUgc2hvd24gbGlrZSBpbiBhIGNpcmNsZS5cbiAgICAgKi9cbiAgICBwcml2YXRlIGdldE5leHRJbWFnZSgpO1xuICAgIC8qKlxuICAgICAqIFByaXZhdGUgbWV0aG9kIHRvIGdldCB0aGUgcHJldmlvdXMgaW5kZXguXG4gICAgICogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSBhdCBpbmRleCAwLCB3aGVuIHlvdSBjYWxsIHByZXYgYWdhaW4sIHlvdSdsbCBnbyB0byB0aGUgbGFzdCBpbWFnZS5cbiAgICAgKiBUaGF0IGhhcHBlbnMgYmVjYXVzZSBhbGwgbW9kYWwgaW1hZ2VzIGFyZSBzaG93biBsaWtlIGluIGEgY2lyY2xlLlxuICAgICAqL1xuICAgIHByaXZhdGUgZ2V0UHJldkltYWdlKCk7XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBtZXRob2QgdG8gYnVpbGQgYSB0ZXh0IGRlc2NyaXB0aW9uLlxuICAgICAqIFRoaXMgaXMgdXNlZCBhbHNvIHRvIGNyZWF0ZSB0aXRsZXMuXG4gICAgICogQHBhcmFtIHtJbWFnZX0gaW1hZ2UgdG8gZ2V0IGl0cyBkZXNjcmlwdGlvbi4gSWYgbm90IHByb3ZpZGVkIGl0IHdpbGwgYmUgdGhlIGN1cnJlbnQgaW1hZ2UuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBpbWFnZVdpdGhvdXREZXNjcmlwdGlvbiBpcyBhIGJvb2xlYW4gdGhhdCBpdCdzIHRydWUgaWYgdGhlIGltYWdlIGhhc24ndCBhICdtb2RhbCcgZGVzY3JpcHRpb24uXG4gICAgICogQHJldHVybnMgU3RyaW5nIGRlc2NyaXB0aW9uIGJ1aWx0IGNvbmNhdGVuYXRpbmcgaW1hZ2UgZmllbGRzIHdpdGggYSBzcGVjaWZpYyBsb2dpYy5cbiAgICAgKi9cbiAgICBwcml2YXRlIGJ1aWxkVGV4dERlc2NyaXB0aW9uKGltYWdlLCBpbWFnZVdpdGhvdXREZXNjcmlwdGlvbik7XG59XG4iXX0=